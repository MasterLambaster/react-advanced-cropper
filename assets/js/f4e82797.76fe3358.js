"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8447],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||a;return n?r.createElement(h,o(o({ref:t},p),{},{components:n})):r.createElement(h,o({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<a;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4754:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var r=n(7462),i=n(3366),a=(n(7294),n(3905)),o=["components"],s={title:"DragEvent",sidebar_position:4},l=void 0,c={unversionedId:"events/DragEvent",id:"events/DragEvent",isDocsHomePage:!1,title:"DragEvent",description:"The drag event is the event that emmits during dragging the different elements like handlers, lines and etc. It emits, for example, by DraggableElement component.",source:"@site/docs/events/DragEvent.mdx",sourceDirName:"events",slug:"/events/DragEvent",permalink:"/react-advanced-cropper/docs/events/DragEvent",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/events/DragEvent.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"DragEvent",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"TransformImageEvent",permalink:"/react-advanced-cropper/docs/events/TransformImageEvent"}},p=[{value:"Anchor",id:"anchor",children:[]},{value:"Shift method",id:"shift-method",children:[]}],u={toc:p};function d(e){var t=e.components,s=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},u,s,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The drag event is the event that emmits during dragging the different elements like handlers, lines and etc. It emits, for example, by ",(0,a.kt)("a",{parentName:"p",href:"'/components/draggable-element.html"},"DraggableElement")," component."),(0,a.kt)("p",null,"This event is represented by ",(0,a.kt)("inlineCode",{parentName:"p"},"DragEvent")," class instance that has four fields:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"nativeEvent")," is the literally last native event related to this drag event"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"element")," is the DOM element that was dragged"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"position")," is the last position of cursor / touch represented by object with ",(0,a.kt)("inlineCode",{parentName:"li"},"left")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"top")," fields relative to window"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"previousPosition")," is the previos position of cursor / touch represented by object with ",(0,a.kt)("inlineCode",{parentName:"li"},"left")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"top")," fields relative to window"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"anchor")," is the geometry coordinates of the point in the handler where touch was started, it is represented by object with ",(0,a.kt)("inlineCode",{parentName:"li"},"left"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"top"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"right")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"bottom")," fields and constant during the current dragging period")),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Overview",src:n(3121).Z})),(0,a.kt)("h2",{id:"anchor"},"Anchor"),(0,a.kt)("p",null,"The anchor is the most misunderstood part of drag event. So let's investigate why is it needed."),(0,a.kt)("p",null,"The right approach to build a stencil resize algorithm is assuming that you don't know anything about the previous cursor / touch position. You just know current position of cursor / touch and current coordinates of handler."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Overview",src:n(764).Z})),(0,a.kt)("p",null,"We should resize stencil in a such way that the mouse cursor will be in ",(0,a.kt)("strong",{parentName:"p"},"the exactly same point")," of handler where user ends dragging. That's is what he anticipates."),(0,a.kt)("p",null,"But if we know only position the following result is the best result that we can ever get."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Overview",src:n(3461).Z})),(0,a.kt)("p",null,"That's the moment when you need to use ",(0,a.kt)("inlineCode",{parentName:"p"},"anchor"),". You just reduce or increase your resize box by anchor coordinates"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Overview",src:n(6689).Z})),(0,a.kt)("h2",{id:"shift-method"},"Shift method"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"DragEvent")," instances have method ",(0,a.kt)("inlineCode",{parentName:"p"},"shift()")," that will accurately calculate the resize shift corresponding to an anchor, a cursor / touch position and a handler position."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Internal structure",src:n(5715).Z})),(0,a.kt)("p",null,"It returns the object with fields ",(0,a.kt)("inlineCode",{parentName:"p"},"left")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"top"),". They will be negative if the corresponding position is decreasing and positive if the corresponding position is increasing."),(0,a.kt)("p",null,"For example, ",(0,a.kt)("inlineCode",{parentName:"p"},"left")," is positive and ",(0,a.kt)("inlineCode",{parentName:"p"},"top")," is negative at the picture above."))}d.isMDXComponent=!0},3461:function(e,t,n){t.Z=n.p+"assets/images/bad-result-50030b2013728169640120cf652a5f41.svg"},6689:function(e,t,n){t.Z=n.p+"assets/images/good-result-ff130983f2e0233f6a76ed27686b9598.svg"},3121:function(e,t,n){t.Z=n.p+"assets/images/overview-b7984de7b87db4baf64cd89b6c7a4d30.svg"},764:function(e,t,n){t.Z=n.p+"assets/images/problem-4aad425416b93b0e2b6d2de0787994a8.svg"},5715:function(e,t,n){t.Z=n.p+"assets/images/shift-method-6e5b1d43b4f6b255a507faa6b8ec66ee.svg"}}]);